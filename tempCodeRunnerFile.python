
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# üèè IPL Player Performance Analysis (EDA)\n",
    "\n",
    "### **Objective**\n",
    "This notebook conducts an in-depth Exploratory Data Analysis (EDA) on the Indian Premier League (IPL) dataset, covering matches and deliveries from 2008 to 2024. The primary goal is to uncover insights into player and team performances, identify top performers, and analyze interesting trends and rivalries over the years.\n",
    "\n",
    "### **Dataset**\n",
    "We are using two primary data files:\n",
    "- `matches.csv`: Contains match-level information like teams, venue, winner, etc.\n",
    "- `deliveries.csv`: Provides ball-by-ball data for each match, including batsman, bowler, runs scored, wickets, etc.\n",
    "\n",
    "You can download the data from [this Kaggle dataset](https://www.kaggle.com/datasets/moumita09/ipl-complete-dataset-2008-2020). *Note: The provided notebook appears to use a more recent version of the dataset.*\n",
    "\n",
    "### **Analysis Highlights**\n",
    "1.  **Data Cleaning & Preparation**: Standardizing and cleaning the raw data for accurate analysis.\n",
    "2.  **Batsman Analysis**: Identifying top run-scorers overall, by team, by season, and at specific venues.\n",
    "3.  **Wicket Taker Analysis**: Finding the most successful bowlers in the league.\n",
    "4.  **Venue & Team Insights**: Analyzing match distribution across cities and team performances at different venues.\n",
    "5.  **Player Rivalries**: A deep dive into classic head-to-head battles between key batsmen and bowlers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries for data manipulation, analysis, and visualization\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import plotly.express as px\n",
    "import plotly.graph_objects as go\n",
    "\n",
    "# Set a consistent style for seaborn plots\n",
    "sns.set(style=\"whitegrid\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<>:2: SyntaxWarning: invalid escape sequence '\\d'\n",
      "<>:3: SyntaxWarning: invalid escape sequence '\\d'\n",
      "<>:2: SyntaxWarning: invalid escape sequence '\\d'\n",
      "<>:3: SyntaxWarning: invalid escape sequence '\\d'\n",
      "C:\\Users\\prera\\AppData\\Local\\Temp\\ipykernel_14392\\2633131778.py:2: SyntaxWarning: invalid escape sequence '\\d'\n",
      "  matches = pd.read_csv(\"..\\data\\matches.csv\")\n",
      "C:\\Users\\prera\\AppData\\Local\\Temp\\ipykernel_14392\\2633131778.py:3: SyntaxWarning: invalid escape sequence '\\d'\n",
      "  deliveries = pd.read_csv(\"..\\data\\deliveries.csv\")\n"
     ]
    }
   ],
   "source": [
    "# Load the datasets from CSV files into pandas DataFrames\n",
    "# 'matches.csv' contains high-level data about each match\n",
    "matches = pd.read_csv(\"..\\\\data\\\\matches.csv\")\n",
    "# 'deliveries.csv' contains ball-by-ball data\n",
    "deliveries = pd.read_csv(\"..\\\\data\\\\deliveries.csv\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üßπ 1. Data Cleaning and Preparation\n",
    "\n",
    "Before analysis, it's crucial to clean the data to ensure its quality and consistency. This involves:\n",
    "- Removing duplicate entries.\n",
    "- Dropping rows with critical missing values (like `winner` or `season`).\n",
    "- Converting data types (e.g., `date` column to datetime objects).\n",
    "- Standardizing column names to a consistent format (lowercase with underscores) for easier access."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "‚úÖ Data cleaned.\n"
     ]
    }
   ],
   "source": [
    "# Define functions to clean the matches and deliveries DataFrames\n",
    "def clean_matches(df):\n",
    "    \"\"\"Cleans the matches DataFrame.\"\"\"\n",
    "    df = df.copy()\n",
    "    # Remove any duplicate rows\n",
    "    df.drop_duplicates(inplace=True)\n",
    "    # Drop rows where essential data like id, season, or winner is missing\n",
    "    df.dropna(subset=[\"id\", \"season\", \"winner\"], inplace=True)\n",
    "    # Convert the 'date' column to datetime objects for time-based analysis\n",
    "    df['date'] = pd.to_datetime(df['date'], errors='coerce')\n",
    "    df = df[df['date'].notnull()]\n",
    "    # Standardize column names to lowercase with underscores for easy access\n",
    "    df.columns = df.columns.str.strip().str.lower().str.replace(\" \", \"_\")\n",
    "    return df\n",
    "\n",
    "def clean_deliveries(df):\n",
    "    \"\"\"Cleans the deliveries DataFrame.\"\"\"\n",
    "    df = df.copy()\n",
    "    # Remove any duplicate rows\n",
    "    df.drop_duplicates(inplace=True)\n",
    "    # Drop rows with essential missing data\n",
    "    df.dropna(subset=[\"match_id\", \"inning\", \"over\", \"ball\"], inplace=True)\n",
    "    # Standardize column names\n",
    "    df.columns = df.columns.str.strip().str.lower().str.replace(\" \", \"_\")\n",
    "    return df\n",
    "\n",
    "# Apply the cleaning functions to the respective DataFrames\n",
    "matches = clean_matches(matches)\n",
    "deliveries = clean_deliveries(deliveries)\n",
    "\n",
    "print(\"‚úÖ Data cleaned.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üìä 2. Overview of the Data\n",
    "\n",
    "Let's get a quick look at the structure and content of our cleaned datasets to understand their scope."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matches dataset shape: (1090, 20)\n",
      "Deliveries dataset shape: (260920, 17)\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "..."
      ],
      "text/plain": [
       "..."
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Display the dimensions (rows, columns) of the matches DataFrame\n",
    "print(\"Matches dataset shape:\", matches.shape)\n",
    "\n",
    "# Display the first few rows of the matches DataFrame to inspect the data\n",
    "matches.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Display the dimensions and the first few rows of the deliveries DataFrame\n",
    "print(\"Deliveries dataset shape:\", deliveries.shape)\n",
    "deliveries.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üèÜ 3. Batsman Performance Analysis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.1. Top 10 Run Scorers in IPL History\n",
    "First, we identify the all-time leading run-scorers in the IPL. We group the `deliveries` data by batsman and sum up their runs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "...",
      "text/plain": [
       "<Figure size 1000x600 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Group deliveries by 'batter' and sum the 'batsman_runs' to get total runs for each player\n",
    "top_batsmen = deliveries.groupby(\"batter\")[\"batsman_runs\"].sum().sort_values(ascending=False).head(10)\n",
    "\n",
    "# Create a bar chart using Matplotlib to visualize the top 10 run-scorers\n",
    "top_batsmen.plot(kind=\"bar\", figsize=(10,6), color='orange', title=\"Top 10 Run Scorers\")\n",
    "plt.ylabel(\"Total Runs\")\n",
    "plt.xlabel(\"Batsman\")\n",
    "plt.xticks(rotation=45) # Rotate x-axis labels for better readability\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Interactive Plot: Top 10 Run Scorers\n",
    "To make the visualization more engaging, we'll recreate the same chart using Plotly Express. This provides an interactive experience with tooltips showing exact run counts."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "batter=%{x}<br>Runs=%{marker.color}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": {
           "bdata": "Th9xGuYZpxmgFXsUPRSFE1oT6xI=",
           "dtype": "i2"
          },
          "coloraxis": "coloraxis",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "V Kohli",
          "S Dhawan",
          "RG Sharma",
          "DA Warner",
          "SK Raina",
          "MS Dhoni",
          "AB de Villiers",
          "CH Gayle",
          "RV Uthappa",
          "KD Karthik"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "Th9xGuYZpxmgFXsUPRSFE1oT6xI=",
          "dtype": "i2"
         },
         "yaxis": "y"
        }
       ],
       "layout": "..."
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Aggregate batsman runs and select the top 10\n",
    "batsman_runs = deliveries.groupby(\"batter\")[\"batsman_runs\"].sum().sort_values(ascending=False).head(10).reset_index()\n",
    "\n",
    "# Create an interactive bar chart using Plotly Express\n",
    "fig = px.bar(\n",
    "    batsman_runs, # DataFrame to use\n",
    "    x=\"batter\",   # X-axis: Batsman names\n",
    "    y=\"batsman_runs\", # Y-axis: Total runs\n",
    "    title=\"Top 10 Run Scorers in IPL\",\n",
    "    labels={\"batsman_runs\": \"Runs\", \"batter\": \"Batsman\"}, # Customize axis labels\n",
    "    color=\"batsman_runs\", # Color bars based on the number of runs\n",
    "    color_continuous_scale=\"Viridis\" # Set the color scale\n",
    ")\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.2. Top 10 Run Scorers by Team\n",
    "Next, we analyze the top run-scorers for each individual IPL team. This helps us understand which players have been the most valuable run-getters for their respective franchises.\n",
    "\n",
    "An interactive dropdown menu allows users to select a team and view its top 10 batsmen."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Teams found: ['Chennai Super Kings' 'Deccan Chargers' 'Delhi Capitals'\\n 'Delhi Daredevils' 'Gujarat Lions' 'Gujarat Titans' 'Kings XI Punjab'\\n 'Kochi Tuskers Kerala' 'Kolkata Knight Riders' 'Lucknow Super Giants'\\n 'Mumbai Indians' 'Pune Warriors' 'Punjab Kings' 'Rajasthan Royals'\\n 'Rising Pune Supergiant' 'Rising Pune Supergiants'\\n 'Royal Challengers Bangalore' 'Royal Challengers Bengaluru'\\n 'Sunrisers Hyderabad']\n"
     ]
    }
   ],
   "source": [
    "# Pre-computation for the dropdown plot\n",
    "\n",
    "# Group by batting team and batsman to get total runs\n",
    "top_per_team = deliveries.groupby([\"batting_team\", \"batter\"])[\"batsman_runs\"].sum().reset_index()\n",
    "\n",
    "# Get a list of all unique teams to create dropdown buttons\n",
    "teams = top_per_team[\"batting_team\"].unique()\n",
    "fig = go.Figure()\n",
    "\n",
    "print(f\"Teams found: {teams}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": "...",
       "layout": "..."
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Create a Plotly figure with a dropdown menu to show top scorers for each team\n",
    "\n",
    "# Iterate through each team to create a separate bar chart (trace)\n",
    "for team in teams:\n",
    "    # Filter the data for the current team and get the top 10 batsmen\n",
    "    team_df = top_per_team[top_per_team[\"batting_team\"] == team].sort_values(\"batsman_runs\", ascending=False).head(10)\n",
    "    \n",
    "    # Add a bar trace for the current team to the figure\n",
    "    fig.add_trace(go.Bar(\n",
    "        x=team_df[\"batter\"],\n",
    "        y=team_df[\"batsman_runs\"],\n",
    "        name=team,\n",
    "        visible=(team == teams[0])  # Only the first team's trace is visible initially\n",
    "    ))\n",
    "\n",
    "# Create the dropdown buttons\n",
    "dropdown_buttons = []\n",
    "for i, team in enumerate(teams):\n",
    "    # Create a visibility list. 'True' for the selected team, 'False' for others.\n",
    "    visible = [False] * len(teams)\n",
    "    visible[i] = True\n",
    "    \n",
    "    # Append a button configuration to the list\n",
    "    dropdown_buttons.append(dict(\n",
    "        label=team, # Button label\n",
    "        method=\"update\", # Method to execute on click\n",
    "        args=[{\"visible\": visible}, # Sets trace visibility\n",
    "              {\"title\": f\"Top 10 Run Scorers for {team}\"}] # Updates the chart title\n",
    "    ))\n",
    "\n",
    "# Add the dropdown menu to the figure's layout\n",
    "fig.update_layout(\n",
    "    updatemenus=[dict(\n",
    "        active=0, # The first button is active by default\n",
    "        buttons=dropdown_buttons,\n",
    "        x=0.5, xanchor=\"center\",\n",
    "        y=1.15, yanchor=\"top\"\n",
    "    )],\n",
    "    title=f\"Top 10 Run Scorers for {teams[0]}\", # Initial title\n",
    "    xaxis_title=\"Batter\",\n",
    "    yaxis_title=\"Runs\"\n",
    ")\n",
    "\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.3. Top 10 Batsmen by Season and Team\n",
    "This analysis adds another layer of granularity by looking at the top 10 batsmen for each team in a specific season. This is useful for understanding player form and impact in particular years.\n",
    "\n",
    "A dropdown menu is created to filter by both season and team."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Merge deliveries with matches to get season information for each delivery\n",
    "grouped = deliveries.merge(matches[[\"id\", \"season\"]], left_on=\"match_id\", right_on=\"id\")\n",
    "\n",
    "# Group by season, team, and batter to get total runs\n",
    "batsman_stats = grouped.groupby([\"season\", \"batting_team\", \"batter\"])[\"batsman_runs\"].sum().reset_index()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Prepare sorted lists of seasons and teams for creating dropdowns\n",
    "seasons = sorted(batsman_stats['season'].unique())\n",
    "teams = sorted(batsman_stats['batting_team'].unique())\n",
    "\n",
    "# Initialize the figure and lists for buttons and visibility\n",
    "fig = go.Figure()\n",
    "buttons = []\n",
    "visibility = []\n",
    "trace_index = 0\n",
    "\n",
    "# Generate one bar chart (trace) for each unique combination of team and season\n",
    "for season in seasons:\n",
    "    for team in teams:\n",
    "        # Filter data for the specific season and team\n",
    "        df_filtered = batsman_stats[\n",
    "            (batsman_stats['season'] == season) & \n",
    "            (batsman_stats['batting_team'] == team)\n",
    "        ].sort_values('batsman_runs', ascending=False).head(10)\n",
    "\n",
    "        # The first trace is visible by default, others are hidden\n",
    "        visible = (season == seasons[0] and team == teams[0])\n",
    "        \n",
    "        # Add the trace to the figure\n",
    "        fig.add_trace(go.Bar(\n",
    "            x=df_filtered['batter'],\n",
    "            y=df_filtered['batsman_runs'],\n",
    "            name=f\"{team} ({season})\",\n",
    "            visible=visible\n",
    "        ))\n",
    "        visibility.append(visible)\n",
    "        trace_index += 1\n",
    "\n",
    "# Create a button for each season-team combination\n",
    "for s_index, season in enumerate(seasons):\n",
    "    for t_index, team in enumerate(teams):\n",
    "        index = s_index * len(teams) + t_index\n",
    "        vis = [False] * trace_index # Start with all traces hidden\n",
    "        vis[index] = True # Make only the relevant trace visible\n",
    "\n",
    "        buttons.append(dict(\n",
    "            label=f\"{team} ({season})\",\n",
    "            method=\"update\",\n",
    "            args=[\n",
    "                {\"visible\": vis},\n",
    "                {\"title\": f\"Top 10 Batsmen for {team} ({season})\"}\n",
    "            ]\n",
    "        ))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": "...",
       "layout": "..."
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Update the layout with the dropdown menu and titles\n",
    "fig.update_layout(\n",
    "    updatemenus=[dict(\n",
    "        active=0,\n",
    "        buttons=buttons, \n",
    "        x=0.5, xanchor=\"center\",\n",
    "        y=1.2, yanchor=\"top\",\n",
    "        direction=\"down\"\n",
    "    )],\n",
    "    title=\"Top 10 Batsmen for Team and Season\",\n",
    "    xaxis_title=\"Batsman\",\n",
    "    yaxis_title=\"Runs\"\n",
    ")\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.4. Top 10 Batsmen by Venue\n",
    "Different grounds can favor different players. This analysis shows which batsmen have dominated at specific venues. A dropdown allows for filtering by each stadium."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total venues: 58\n",
      "..."
     ]
    }
   ],
   "source": [
    "# Merge deliveries and matches to link deliveries to venues\n",
    "merged_df = deliveries.merge(matches[['id', 'venue']], left_on='match_id', right_on='id')\n",
    "\n",
    "# Group by venue and batsman to get total runs scored at each venue\n",
    "venue_batsmen = merged_df.groupby(['venue', 'batter'])['batsman_runs'].sum().reset_index()\n",
    "\n",
    "# Get a list of unique venues for the dropdown\n",
    "venues = venue_batsmen['venue'].unique()\n",
    "print(f\"Total venues: {venues.shape[0]}\")\n",
    "print(f\"Venues found: {venues}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Initialize figure and buttons list\n",
    "fig = go.Figure()\n",
    "buttons = []\n",
    "\n",
    "# Build a trace for each venue\n",
    "for i, venue in enumerate(venues):\n",
    "    # Filter for the current venue and get top 10 batsmen\n",
    "    top_batsmen = venue_batsmen[venue_batsmen['venue'] == venue]\\\n",
    "                    .sort_values('batsman_runs', ascending=False)\\\n",
    "                    .head(10)\n",
    "\n",
    "    # Add a bar trace for the venue, visible only if it's the first one\n",
    "    fig.add_trace(go.Bar(\n",
    "        x=top_batsmen['batter'],\n",
    "        y=top_batsmen['batsman_runs'],\n",
    "        name=venue,\n",
    "        visible=(i == 0)\n",
    "    ))\n",
    "\n",
    "    # Create the visibility array for the dropdown\n",
    "    vis = [False] * len(venues)\n",
    "    vis[i] = True\n",
    "\n",
    "    # Create the button for the dropdown\n",
    "    buttons.append(dict(\n",
    "        label=venue,\n",
    "        method=\"update\",\n",
    "        args=[\n",
    "            {\"visible\": vis},\n",
    "            {\"title\": f\"Top 10 Batsmen at {venue}\"}\n",
    "        ]\n",
    "    ))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": "...",
       "layout": "..."
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Update the layout of the figure with the dropdown menu and titles\n",
    "fig.update_layout(\n",
    "    updatemenus=[\n",
    "        dict(\n",
    "            buttons=buttons,\n",
    "            active=0,\n",
    "            x=0.5, xanchor=\"center\",\n",
    "            y=1.15, yanchor=\"top\",\n",
    "            direction=\"down\"\n",
    "        )\n",
    "    ],\n",
    "    title=f\"Top 10 Batsmen at {venues[0]}\", # Set initial title\n",
    "    xaxis_title=\"Batsman\",\n",
    "    yaxis_title=\"Runs\"\n",
    ")\n",
    "\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üéØ 4. Top Wicket Takers Analysis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.1. Top 10 Wicket Takers in IPL History\n",
    "Similar to the batsman analysis, we now identify the all-time leading wicket-takers. We filter the data for actual dismissals (bowled, caught, lbw, etc.) and then group by the bowler."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "...",
      "text/plain": [
       "<Figure size 1000x600 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Filter for deliveries that resulted in a legitimate wicket credited to the bowler\n",
    "wickets = deliveries[deliveries.dismissal_kind.isin([\"bowled\", \"caught\", \"lbw\", \"stumped\", \"caught and bowled\"])]\n",
    "\n",
    "# Group by 'bowler' and count the number of dismissals\n",
    "top_bowlers = wickets.groupby(\"bowler\").count()[\"player_dismissed\"].sort_values(ascending=False).head(10)\n",
    "\n",
    "# Create a bar chart using Matplotlib to visualize the top 10 wicket-takers\n",
    "top_bowlers.plot(kind=\"bar\", figsize=(10,6), color='green', title=\"Top 10 Wicket Takers\")\n",
    "plt.ylabel(\"Wickets\")\n",
    "plt.xlabel(\"Bowler\")\n",
    "plt.xticks(rotation=45)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Interactive Plot: Top 10 Wicket Takers\n",
    "An interactive version of the wicket-takers chart using Plotly."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": "...",
       "layout": "..."
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Aggregate wicket data for the top 10 bowlers\n",
    "top_bowlers = wickets.groupby(\"bowler\").count()[\"player_dismissed\"].sort_values(ascending=False).head(10).reset_index()\n",
    "\n",
    "# Create an interactive bar chart with Plotly Express\n",
    "fig = px.bar(\n",
    "    top_bowlers,\n",
    "    x=\"bowler\",\n",
    "    y=\"player_dismissed\",\n",
    "    title=\"Top 10 Wicket Takers in IPL\",\n",
    "    labels={\"player_dismissed\": \"Wickets\", \"bowler\": \"Bowler\"},\n",
    "    color=\"player_dismissed\",\n",
    "    )\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.2 Top 10 Wicket Takers by Team, Season, and Venue\n",
    "Similar to the batsman analysis, we can create detailed, filterable charts for bowlers based on:\n",
    "- Team\n",
    "- Season and Team\n",
    "- Venue\n",
    "\n",
    "The code structure is analogous to the batsman sections, using dropdown menus for interactive filtering."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": "...",
   "source": [
    "# (This is a sample of one of the bowler analyses - Top Wicket Takers per Team)\n",
    "\n",
    "# Group by bowling team and bowler to get total wickets\n",
    "top_per_team_wickets = wickets.groupby([\"bowling_team\", \"bowler\"])[\"player_dismissed\"].count().reset_index()\n",
    "teams_wickets = top_per_team_wickets[\"bowling_team\"].unique()\n",
    "fig = go.Figure()\n",
    "print(f\"Teams found: {teams_wickets}\")\n",
    "\n",
    "dropdown_buttons_wickets = []\n",
    "for i, team in enumerate(teams_wickets):\n",
    "    team_df = top_per_team_wickets[top_per_team_wickets[\"bowling_team\"] == team].sort_values(\"player_dismissed\", ascending=False).head(10)\n",
    "    fig.add_trace(go.Bar(\n",
    "        x=team_df[\"bowler\"],\n",
    "        y=team_df[\"player_dismissed\"],\n",
    "        name=team,\n",
    "        visible=(i == 0)\n",
    "    ))\n",
    "    visible = [False] * len(teams_wickets)\n",
    "    visible[i] = True\n",
    "    dropdown_buttons_wickets.append(dict(\n",
    "        label=team,\n",
    "        method=\"update\",\n",
    "        args=[{\"visible\": visible},\n",
    "              {\"title\": f\"Top 10 Wicket Takers for {team}\"}]\n",
    "    ))\n",
    "\n",
    "fig.update_layout(\n",
    "    updatemenus=[dict(\n",
    "        active=0,\n",
    "        buttons=dropdown_buttons_wickets,\n",
    "        x=0.5, xanchor=\"center\",\n",
    "        y=1.15, yanchor=\"top\"\n",
    "    )],\n",
    "    title=f\"Top 10 Wicket Takers for {teams_wickets[0]}\",\n",
    "    xaxis_title=\"Bowler\",\n",
    "    yaxis_title=\"Wickets\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üó∫Ô∏è 5. Venue and City Analysis\n",
    "\n",
    "### 5.1. Cities with the Most Matches Hosted\n",
    "This visualization shows the top 10 cities that have hosted the most IPL matches, giving an idea of the most frequent locations for the tournament."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "...",
      "text/plain": [
       "<Figure size 1000x600 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Count the number of matches in each city and select the top 10\n",
    "city_match_counts = matches['city'].value_counts().head(10)\n",
    "\n",
    "# Create a bar chart to show the cities with the most matches\n",
    "city_match_counts.plot(kind=\"bar\", figsize=(10,6), color='purple', title=\"Cities with Most Matches\")\n",
    "plt.ylabel(\"Match Count\")\n",
    "plt.xlabel(\"City\")\n",
    "plt.xticks(rotation=45)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.2. Team Appearances by City\n",
    "This interactive chart breaks down which teams have played the most matches in each city. A dropdown menu allows for filtering by city."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": "...",
       "layout": "..."
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Group data to count how many times each team played in each city (as team1 or team2)\n",
    "team1 = matches.groupby(['city', 'team1'])['id'].count().reset_index(name='matches')\n",
    "team2 = matches.groupby(['city', 'team2'])['id'].count().reset_index(name='matches')\n",
    "\n",
    "# Rename columns to a standard 'team' name for concatenation\n",
    "team1.rename(columns={'team1': 'team'}, inplace=True)\n",
    "team2.rename(columns={'team2': 'team'}, inplace=True)\n",
    "\n",
    "# Combine both DataFrames and aggregate the counts\n",
    "team_matches = pd.concat([team1, team2])\n",
    "team_matches = team_matches.groupby(['city', 'team'])['matches'].sum().reset_index()\n",
    "\n",
    "# Get a sorted list of unique cities for the dropdown menu\n",
    "cities = sorted(team_matches['city'].dropna().unique())\n",
    "\n",
    "# Create figure and dropdown options\n",
    "fig = go.Figure()\n",
    "buttons = []\n",
    "\n",
    "# Create a trace for each city\n",
    "for i, city in enumerate(cities):\n",
    "    city_df = team_matches[team_matches['city'] == city].sort_values('matches', ascending=False)\n",
    "\n",
    "    fig.add_trace(go.Bar(\n",
    "        x=city_df['team'],\n",
    "        y=city_df['matches'],\n",
    "        name=city,\n",
    "        visible=(i == 0) # Only the first city is visible by default\n",
    "    ))\n",
    "\n",
    "    vis = [False] * len(cities)\n",
    "    vis[i] = True\n",
    "\n",
    "    buttons.append(dict(\n",
    "        label=city,\n",
    "        method=\"update\",\n",
    "        args=[\n",
    "            {\"visible\": vis},\n",
    "            {\"title\": f\"Matches Played by Teams in {city}\"}\n",
    "        ]\n",
    "    ))\n",
    "\n",
    "# Add dropdown to the figure's layout\n",
    "fig.update_layout(\n",
    "    updatemenus=[\n",
    "        dict(\n",
    "            buttons=buttons,\n",
    "            active=0,\n",
    "            x=0.5, xanchor=\"center\",\n",
    "            y=1.25, yanchor=\"top\",\n",
    "            direction=\"down\"\n",
    "        )\n",
    "    ],\n",
    "    title=f\"Matches Played by Teams in {cities[0]}\",\n",
    "    xaxis_title=\"Team\",\n",
    "    yaxis_title=\"Number of Matches\"\n",
    ")\n",
    "\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ‚öîÔ∏è 6. Head-to-Head: Batsman vs. Bowler Rivalries\n",
    "This final section provides a detailed look at the most intense rivalries between individual batsmen and bowlers, ranked by the number of balls faced. \n",
    "\n",
    "The interactive chart shows:\n",
    "- **Runs Scored** (Y-axis)\n",
    "- **Balls Faced** (Color of the bar)\n",
    "- Additional details in the tooltip: **Outs**, **Boundaries**, and **Innings Faced**."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 128,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": "...",
       "layout": "..."
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Prepare head-to-head data by aggregating key stats for each batter-bowler pair\n",
    "h2h_df = deliveries[['batter', 'bowler', 'batsman_runs', 'player_dismissed', 'match_id']].copy()\n",
    "\n",
    "# 1. Total balls faced\n",
    "balls = h2h_df.groupby(['batter', 'bowler']).size().reset_index(name='balls_faced')\n",
    "\n",
    "# 2. Total runs scored\n",
    "runs = h2h_df.groupby(['batter', 'bowler'])['batsman_runs'].sum().reset_index(name='runs')\n",
    "\n",
    "# 3. Total dismissals (outs)\n",
    "dismissals = h2h_df[h2h_df['batter'] == h2h_df['player_dismissed']]\\\n",
    "    .groupby(['batter', 'bowler'])['player_dismissed'].count().reset_index(name='outs')\n",
    "\n",
    "# 4. Boundaries (4s and 6s)\n",
    "boundaries = h2h_df[h2h_df['batsman_runs'].isin([4, 6])]\n",
    "boundary_count = boundaries.groupby(['batter', 'bowler'])['batsman_runs'].count().reset_index(name='boundaries')\n",
    "\n",
    "# 5. Unique innings/matches faced\n",
    "innings_count = h2h_df.groupby(['batter', 'bowler'])['match_id'].nunique().reset_index(name='innings_faced')\n",
    "\n",
    "# Merge all the stats into a single DataFrame\n",
    "merged_h2h = balls.merge(runs, on=['batter', 'bowler'], how='left')\\\n",
    "                  .merge(dismissals, on=['batter', 'bowler'], how='left')\\\n",
    "                  .merge(boundary_count, on=['batter', 'bowler'], how='left')\\\n",
    "                  .merge(innings_count, on=['batter', 'bowler'], how='left')\n",
    "\n",
    "# Fill any missing values with 0 (e.g., if no boundaries were hit or no outs occurred)\n",
    "merged_h2h.fillna(0, inplace=True)\n",
    "merged_h2h[['runs', 'outs', 'boundaries', 'innings_faced']] = merged_h2h[['runs', 'outs', 'boundaries', 'innings_faced']].astype(int)\n",
    "\n",
    "# Get the top 10 rivalries based on the number of balls faced\n",
    "top_10_rivalries = merged_h2h.sort_values('balls_faced', ascending=False).head(10).reset_index(drop=True)\n",
    "\n",
    "# Create a combined label for the x-axis\n",
    "top_10_rivalries['label'] = top_10_rivalries['batter'] + \" vs \" + top_10_rivalries['bowler']\n",
    "\n",
    "# Create the interactive bar chart using Plotly Express\n",
    "fig = px.bar(\n",
    "    top_10_rivalries,\n",
    "    x='label',\n",
    "    y='runs',\n",
    "    hover_data=['balls_faced', 'outs', 'boundaries', 'innings_faced'], # Data to show on hover\n",
    "    color='balls_faced', # Bar color indicates balls faced\n",
    "    title='Top 10 Batsman vs Bowler Rivalries (By Balls Faced)'\n",
    ")\n",
    "\n",
    "# Customize the layout for better readability\n",
    "fig.update_layout(\n",
    "    xaxis_title='Rivalry (Batsman vs Bowler)',\n",
    "    yaxis_title='Runs Scored',\n",
    "    xaxis_tickangle=-30 # Angle the x-axis labels\n",
    ")\n",
    "\n",
    "fig.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}